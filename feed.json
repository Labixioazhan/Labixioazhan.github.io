{"title":"Boolean","description":"程序员小白","language":"","link":"https://labixioazhan.github.io","pubDate":"Thu, 13 Aug 2020 12:06:31 GMT","lastBuildDate":"Thu, 13 Aug 2020 12:09:44 GMT","generator":"hexo-generator-json-feed","webMaster":"徐展","items":[{"title":"Spring MVC","link":"https://labixioazhan.github.io/2020/08/13/Spring-MVC/","description":"一 MVC思想:M:model模型,业务逻辑,数据存储 V:view视图,界面排版布局,展示模型数据 C:controller控制器 接受用户请求,交给模型对象处理选择视图 Spring MVC 请求 当请求离开浏览器后,会带有用户所请求内容的信息,然后到达Spring的DispatcherServlet,这时候Spring MVC的所有请求都会通过一个前端控制器Servlet,是一个单例的Servlet将请求委托给应用程序的其他组件来执行实际的处理,在Spring MVC中DispatcherServlet就是一个前端控制器. DispatcherServlet的任务是将请求发送给Spring MVC 控制器,控制器是一个用于处理请求的Spring组件.所以DispatcherServlet会查询一个或者多个处理器映射(handle mapping)来确定请求的下一站 一旦选择了控制器,DispatcherServlet就会将请求发送给选中的控制器,到达控制器后请求会卸下用户提交的数据并等待处理器处理这些信息 控制器完成逻辑处理后,通常会产生一些信息,这些信息需要返回给用户并且显示在浏览器上,这些信息被称为模型model,这些信息要以用户有好的方式进行格式化,一般是HTML,所有信息需要发送给一个视图View.通常是jsp 控制器经模型数据打包,并且标注用于渲染输出的视图明,会将请求连同模型和视图名发送回DispatcherServlet. 这样控制器就不会与特定的视图相耦合,传递给DispatcherServlet的视图名并不直接表示某个特定的jsp,DispatcherServlet会使用视图解析器来将逻辑视图名匹配一个特定的视图 二 使用注解方式开发helloworld程序在MVC框架中的存在一个前端控制器,用来提供一个集中请求处理机制,所有的请求都被发往该控制器统一处理,然后把请求发送给相应的处理程序,一般用来做一个共同处理,如权限检查,授权,日志等.Spring MVC中提供了一个DispatcherServlet作为前端控制钱,要使用的话必须要在web.xml中配置,处理请求对象的处理器称为后端处理器controller. 配置DispatcherServlet 12345678910111213141516&lt;!--前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--指定Spring MVC加载配置文件 会启动web环境下的Servlet--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--Tomcat启动初始化--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置mvc.xml 1234&lt;!--配置IOC DI注解解析器,--&gt; &lt;context:component-scan base-package=\"cn.wolfcode.web.controller\"&gt;&lt;/context:component-scan&gt; &lt;!--MVC注解解析器--&gt; &lt;mvc:annotation-driven/&gt; 控制器 12345678910111213@Controllerpublic class HelloController &#123; //提供方法处理请求, @RequestMapping(\"/hello\") public ModelAndView save()&#123; ModelAndView modelAndView = new ModelAndView(); //往作用与内或者模型中注入数据 modelAndView.addObject(\"msg\",\"hello MVC\"); //找视图 modelAndView.setViewName(\"WEB-INF/views/welcome.jsp\"); return modelAndView; &#125;&#125; 分析: load-on-startup是可选元素,若值为0或者大于0时,表示容器在应用启动时就构建servlet并调用init方法初始化操作(非负值越小,优先级越高),若是一个负数,则在第一次请求serlvet加载 注解: @RequestMapping:是一个用来处理地址映射的注解,可用于类或者方法上,用于类上表示该类中所有响应请求的方法都是以该路径作为父路径,还可以限定请求类型和响应类型 前端控制器映射路径映射路径 配置如 .do、.htm 是最传统方式，可以访问静态文件（图片、 JS、 CSS 等），但不支持 RESTful风格。 配置成 /，可以支持流行的 RESTful 风格，但会导致静态文件（图片、 JS、 CSS 等）被拦截后不能访问。 配置成 /*，是错误的方式，可以请求到 Controller 中，但跳转到调转到 JSP 时被拦截，不能渲染JSP 视图，也会导致静资源访问不了。 访问静态资源和JSP 被拦截的原因 Tomcat 容器处理静态资源是交由内置 DefaultServlet 来处理的（拦截路径是 /），处理 JSP 资源是交由内置的 JspServlet 处理的（拦截路径是.jsp | .jspx）。 启动项目时，先加载容器的 web.xml，而后加载项目中的 web.xml。当拦截路径在两者文件中配置的一样，后面会覆盖掉前者。所以前端控制器配置拦截路径是 / 的所有静态资源都会交由前端控制器处理，而拦截路径配置 /*，所有静态资源和 JSP 都会交由前端控制器处理。 访问静态资源 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在控制器里的处理方法,请求路径必须携带.do 123&lt;!--该配置会在Spring mvc 上下文中创建存入一个bean, 对DIspatcherServlet进行筛选,如果不是映射请求,就交给容器默认的Servlet处理--&gt; &lt;mvc:default-servlet-handler/&gt; #### 三处理响应 响应处理是指怎么编写控制器里面的处理方法接受请求做响应，找视图文件和往作用域中存入数据。要处理方法要做响应，一般处理方法返回的类型为 ModelAndView 和 String。 ModelAndView 123456789101112131415@Controllerpublic class ResponseController &#123; //提供方法处理请求 @RequestMapping(\"/resp1\") public ModelAndView resp()&#123; //创建对象 ModelAndView modelAndView = new ModelAndView(); //往作用域或者模型中存入数据 modelAndView.addObject(\"msg\",\"返回类型是ModelAndView\"); //找视图 modelAndView.setViewName(\"WEB-INF/views/resp.jsp\"); return modelAndView; &#125; &#125; addObject():设置共享数据的key和value 返回String 12345678//提供方法处理请求 @RequestMapping(\"/resp2\") public String resp2(Model model)&#123; //往作用域或者模型中存入数据 model.addAttribute(\"msg\",\"返回类型是ModelAndView\"); //找视图 return \"WEB-INF/views/resp.jsp\"; &#125; 12345&lt;!--配置视图解析器 Spring MVC找视图的路径就是 前缀+视图名+后缀--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/views\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; 请求转发与重定向 12return \"forward:/WEB-INF/views/hello.jsp\";return \"redirect:/WEB-INF/views/hello.jsp\" 四处理请求参数请求参数名和处理方法的形参同名 1234567//提供方法处理请求 @RequestMapping(\"/resp3\") public ModelAndView resp3(String username,int age)&#123; System.out.println(username); System.out.println(age); return null; &#125; 请求参数名和处理方法的形参不同名 1234567//提供方法处理请求 @RequestMapping(\"/resp4\") public ModelAndView resp4(@RequestParam(\"username\") String name, int age)&#123; System.out.println(name); System.out.println(age); return null; &#125; post方式乱码 12345678910111213&lt;!--编码过滤器,post方式--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 请求复合类型的请求参数 数组类型/resp.do?ids=1&amp;ids=2&amp;ids=3 12345@RequestMapping(\"/resp5\") public ModelAndView resp5(Long[] ids)&#123; System.out.println(Arrays.toString(ids)); return null; &#125; 自定义类型,定义类来封装值,在方法中传入该类型参数 处理日期格式 12345@RequestMapping(\"/req\") public ModelAndView req(@DateTimeFormat(pattern = \"yyyy-MM-dd\")Date date)&#123; System.out.println(date.toString()); return null; &#125; 如果是自定义类型,直接在属性上贴注解@DateTimeFormat(pattern = “yyyy-MM-dd”) @ModelAttrubute(“id”)给形参贴该注解,用来修改模型中使用的key 五文件上传1234567891011121314@Controllerpublic class UploadController &#123; //Spring容器存在ServletContect对象 @Autowired private ServletContext servletContext; public ModelAndView upload(Part pic) &#123; System.out.println(pic.getContentType()); //FileCopyUtils.copy(in,out); //获取项目webapp目录下uploadDir的绝对路径 System.out.println(servletContext.getRealPath(\"/uploadDir\")); return null; &#125;&#125; 12&lt;!--配置上传解析器--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.support.StandardServletMultipartResolver\"&gt;&lt;/bean&gt; 六拦截器12345678910 &lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--被排除的路径--&gt;&lt;!-- &lt;mvc:exclude-mapping path=\"排除路径\"/&gt;--&gt; &lt;!--拦截器--&gt; &lt;bean class=\"cn.wolfcode.web.interceptor.MyInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 123456789101112131415161718192021public class MyInterceptor implements HandlerInterceptor &#123; //处理方法之前 //返回false就被拦截,返回true就放行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"preHandle\"); return true; &#125; //处理方法之后,渲染视图之前 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"postHandle\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"afterCompletion\"); &#125;&#125;","pubDate":"Thu, 13 Aug 2020 12:06:31 GMT","guid":"https://labixioazhan.github.io/2020/08/13/Spring-MVC/","category":"Spring MVC"},{"title":"IOC和DI注解以及动态代理","link":"https://labixioazhan.github.io/2020/08/09/IOC和DI注解以及动态代理/","description":"注解实现Ioc 和DIxml的配置方式可以很清楚了解ioc和DI的方式,但是配置过程较为复杂,所以要使用注解的方式简化开发. @value:注入常量值 Spring 包下的 @Autowired 可以让 Spring 自动的把属性或字段需要的对象找出来，并注入到属性上或字段上。 可以贴在字段或者 setter 方法上面。 可以同时注入多个对象。 可以注入一些 Spring 内置的重要对象，比如 BeanFactory，ApplicationContext 等。 默认情况下 Autowired 注解必须要能找到对应的对象，否则报错。通过 required=false 来避免这个问题：@Autowired(required=false)。 Autowired 注解寻找 bean 的方式： ​ 首先按照依赖对象的类型找，若找到，就是用 setter 或者字段直接注入。 ​ 如果在 Spring 上下文中找到多个匹配的类型，再按照名字去找，若没有匹配报错。 ​ 可以通过使用 @Qualifier(“other”) 标签来规定依赖对象按照 bean 的 id 和 类型的组合方式去找。 JavaEE下的Resource Resource和Autowired使用基本类似,大多数情况下可以直接替换","pubDate":"Sun, 09 Aug 2020 03:08:02 GMT","guid":"https://labixioazhan.github.io/2020/08/09/IOC和DI注解以及动态代理/","category":"spring"},{"title":"spring基础","link":"https://labixioazhan.github.io/2020/08/07/spring基础/","description":"一 装配bean1.1 自动化装配Spring会从两个角度来实现自动化装配: ​ 组件扫描:Spring会自动发现应用上下文中所创建的bean. ​ 自动装配:Spring自动满足bean之间的依赖 @component注解用在类上表明该类会作为组件,并且告知Spring要为这个类创建bean 但是组件扫描默认时不启用的,需要显示配置spring,让它去寻找带有@component注解的类 123@Configtuation@ComponentScanpublic class XXXConfig&#123;&#125; @componentScan注解默认会扫描与配置类相同的包以及该包下所有子包,查找带有@Component注解的类为其创建一个bean @componentScan(“包名”)可以单独设置扫描的包 @Component(basePackages={“包名1”,”包名2”})设置扫描多个包 @Component(basePackageClasses={xxx.class,vvv.class}来为指定包中所包含的接口和类 @Configtuation注解用于告诉Spring这是一个配置类 还可以使用xml方式开启组件扫描:可以使用Springcontext命名空间 1&lt;context:component-scan base-package = \"包名\"&gt;&lt;/context:component-scan&gt;","pubDate":"Fri, 07 Aug 2020 08:58:37 GMT","guid":"https://labixioazhan.github.io/2020/08/07/spring基础/","category":"Spring"},{"title":"Mybatis","link":"https://labixioazhan.github.io/2020/08/06/Mybatis/","description":"mybatis基于xml的操作(不写实现类)myabtis配置文件:这里使用properties文件将数据库相关信息抽取 注意一定要在最后引入映射文件的位置 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--作用: 引用数据库配置文件 --&gt; &lt;properties resource=\"db.properties\"/&gt; &lt;!--作用: 配置环境(可以配多个)--&gt; &lt;environments default=\"development\"&gt; &lt;!--作用: 配置环境变量--&gt; &lt;environment id=\"development\"&gt; &lt;!--作用: 事物管理器 JDBC 含义:使用jdbc类型的事务管理器 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--作用:数据源 POOLED含义:数据源类型:数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driverClassName&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--作用:配置去哪里可以找到sql映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"cn\\wolfcode\\dao\\EmpDao.xml\"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt;","pubDate":"Thu, 06 Aug 2020 10:00:21 GMT","guid":"https://labixioazhan.github.io/2020/08/06/Mybatis/","category":"mybatis"},{"title":"Maven的安装与配置","link":"https://labixioazhan.github.io/2020/08/03/Maven/","description":"Mavenmaven的安装 检查JDK版本,打开命令行输入java -version,如果报错可能是没有配置环境变量导致的,给java配置环境变量 将下载好的maven压缩包解压,解压后的路径最好不要使用中文和空格\\ 配置maven的环境变量 打开命令行输入mvn -v检查是否安装成功 maven设置本地仓库路径和更改仓库镜像 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;!-- 本地仓库地址 --&gt; &lt;localRepository&gt;你本地仓库的目录位置&lt;/localRepository&gt; &lt;mirrors&gt; &lt;!-- 阿里仓库镜像 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;/settings&gt;","pubDate":"Mon, 03 Aug 2020 06:16:45 GMT","guid":"https://labixioazhan.github.io/2020/08/03/Maven/","category":"Maven"},{"title":"myPhoto","link":"https://labixioazhan.github.io/2020/08/02/myPhoto/","description":"","pubDate":"Sun, 02 Aug 2020 06:00:05 GMT","guid":"https://labixioazhan.github.io/2020/08/02/myPhoto/","category":"photo"},{"title":"Hello World","link":"https://labixioazhan.github.io/2020/08/02/hello-world/","description":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","pubDate":"Sun, 02 Aug 2020 02:16:46 GMT","guid":"https://labixioazhan.github.io/2020/08/02/hello-world/","category":""}]}