{"title":"Labixiaozhan的博客","description":"程序员小白","language":"","link":"https://labixioazhan.github.io","pubDate":"Fri, 07 Aug 2020 08:58:37 GMT","lastBuildDate":"Fri, 07 Aug 2020 08:59:34 GMT","generator":"hexo-generator-json-feed","webMaster":"徐展","items":[{"title":"spring基础","link":"https://labixioazhan.github.io/2020/08/07/spring基础/","description":"一 装配bean1.1 自动化装配Spring会从两个角度来实现自动化装配: ​ 组件扫描:Spring会自动发现应用上下文中所创建的bean. ​ 自动装配:Spring自动满足bean之间的依赖 @component注解用在类上表明该类会作为组件,并且告知Spring要为这个类创建bean 但是组件扫描默认时不启用的,需要显示配置spring,让它去寻找带有@component注解的类 123@Configtuation@ComponentScanpublic class XXXConfig&#123;&#125; @componentScan注解默认会扫描与配置类相同的包以及该包下所有子包,查找带有@Component注解的类为其创建一个bean @componentScan(“包名”)可以单独设置扫描的包 @Component(basePackages={“包名1”,”包名2”})设置扫描多个包 @Component(basePackageClasses={xxx.class,vvv.class}来为指定包中所包含的接口和类 @Configtuation注解用于告诉Spring这是一个配置类 还可以使用xml方式开启组件扫描:可以使用Springcontext命名空间 1&lt;context:component-scan base-package = \"包名\" 1.2为组件扫描的bean命名默认情况下,spring会根据类名将首字母小写作为bean的id. 在使用@component注解时可以传入bean的值 @Component(“name”)或者使用@named(“name)为bean起名 1.3通过为bean添加注解实现自动装配@Autowired注解不仅能用在构造器上,还能用在setter方法上.如果有且只用一个bean匹配依赖需求,那么这个bean就会被装配,如果没有匹配的bean,那么在应用上下文创建的时候Spring会抛出异常.为了避免该异常你可以使用@Autowired(required=false).这样Spring会尝试自动装配,如果没有匹配的bean,会让这个bean为未装配状态,但是如果你在代码中没有进行null检查的话,就会出来你空指针异常 @AutoWired时spring特定注解,如果你不想使用可以使用@Inject(源于java依赖注入桂发)注解来替换 1.4通过java代码来装配bean有的时候自动化装配是行不通,比如将第三方库中的组件装配到你的应用中,这时候没办法使用@Component注解只能配置Spring来实现 使用@Configuration来创建一个配置类,在该类中使用@Bean注解来创建bean,该注解会告诉Spring这个方法会返回一个对象,该对象注册为Spring应用上下文中的bean,同时也可以使用name=“”属性指定一个名称. 通过xml装配bean: 创建xml配置规范,然后创建 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"a xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--方式一直接创建bean--&gt; &lt;bean class=\"权限定类名\" id=\"bean名称\"&gt;&lt;/bean&gt; &lt;!--方式二使用构造器创建bean--&gt; &lt;bean class=\"权限定类名\" id=\"bean名称\"&gt; &lt;constructor-arg ref=\"配置过bean的id\" value=\"要注入的值\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg &gt; &lt;list&gt; &lt;value&gt;传入构造器所需的值&lt;/value&gt; &lt;ref bean= \"已配置过的beanid\"&gt;传入bean对象&lt;/ref&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;property name=\"设置的属性名\" ref = \"\"&gt;为bean对象设置属性值&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; @Improt导入将配置类组和在一起 二 高级装配##### 2.1条件化的bean 假如你希望一个或者多个bean只有在应用的路径下包含特定的库时才创建或者我们希望某个bean 只有当另外特定的bean声明之后创建.这个时候可以使用@Conditional注解,可以用到带有@bean注解的方法上,给定计算结果为真时才会创建bean对象,否则就会忽略. @Conditonal注解中会指明一个Class,会通过Condition接口进行对比,设置@Conditional的类可以是任意实现类Condition接口的类型,只需提供matcher()方法 ConditionContext接口可以借助getRegistry()检查bean的定义,借助getBeanFactory()检查版是否存在.借助getEnvironment()返回Environment检查环境变量是否存在以及值是什么,借助getClassLoader()返回的ClassLoader加载并检查类是否存在 2.2处理自动装配的歧义行12345678910@Autowiredpublic void setDessert(Dessert sessert)&#123; &#125;@Componentpublic class Cake implements Dessert&#123;&#125;@Componentpublic class Cookie implements Dessert&#123;&#125;@Componentpublic class IceCream implements Dessert&#123;&#125; 因为三个实现类均使用类@component注解,组件扫描是,能够发现并且创建spring应用上下文里的bean,当自动装配setDessert时就会发生歧义,不知道该选择哪个bean装配,Spring会抛出NoUniqueBeanDefinitionException异常. @Primary和@Component组合使用,可以使得该bean被设置为首选,但是如果当首选bean数量超过一个是就没办法缩小范围.这个时候使用@qualifier(“name”)注解和@Autowired组合使用,将自己想要注入的bean注入. 2.3bean的作用域默认情况下,Spring应用上下文中的所有bean都是以单例(singleton)的,不管注入多少次,都只是注入同一个实例 @Scope注解来为bean指明作用域,也可以在xml文件声明bean 使用scope属性来改变bean的作用域. 单例singleton:整个应用中,只创建beany一次 原型Prototype:每次注入或者通过Spring上下文获取的时候,都会创建一个bean实例. 会话Session:在web应用中,为每一个会话创建一个bean实例 请求Request:在web应用中,为每一个请求创建一个bean实例 在xml中不能直接使用scope来声明会话或者请求域的bean,需要使用proxyMode属性来设置,声明作用域代理 三 面向切面的Spring4.1AOP通知:定义切面是什么以及何时使用 ​ 前置通知Before:在目标方法被调用之前使用 ​ 后置通知After:在目标方法完成后调用通知,此时不关心输出是什么 ​ 返回通知:After-returning:在目标方法成功执行之后调用通知 ​ 异常通知:After-throwing:在目标方法抛出异常后调用通知 ​ 环绕通知Around:通知包裹了被通知的方法,在被通知的方法到调用之前和之后执行自定义行为 连接点:连接点是应用在执行过程中能够切入面的一个点 切点:定义了何处,切点定义会匹配通知索要织入的一个或者多个连接点 切面Aspect:通知和切点的节后, 引入Introduction:向向有的类添加新的方法 织入Weaving:把切面应用到目标对象并创建新的代理对象的过程 基于xml实现aop的通知直接使用业务层模拟个业务的执行 12345678910111213141516171819202122/** * 账户的业务层接口 * @author xuzhan */public interface IAccountService &#123; /** * 模拟保存账户 */ void saveAccount(); /** * 模拟更新账户 * @param i */ void updateAccount(int i); /** * 模拟删除账户 * @return */ int deleteAccount();&#125; 1234567891011121314151617public class AccountServiceImpl implements IAccountService &#123; @Override public void saveAccount() &#123; System.out.println(\"执行了保存\"); &#125; @Override public void updateAccount(int i) &#123; System.out.println(\"执行了更新\" + i); &#125; @Override public int deleteAccount() &#123; System.out.println(\"执行了删除\"); return 0; &#125;&#125; logger类中的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 用于记录日志的工具类,提供公共的代码 * @author xuzhan */public class Logger &#123; /** * 前置通知 */ public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了\"); &#125; /** * 异常通知 */ public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了\"); &#125; /** * 后置通知 */ public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了\"); &#125; /** * 最终通知 */ public void afterPrintLog() &#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了\"); &#125; /** * 环绕通知 */ public void aroundPrintLog() &#123; System.out.println(\"Loger类中的aroundPrintLog方法开始记录日志了\"); &#125;&#125; xml文件的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--配置spring的AOP把service对象配置进来--&gt; &lt;bean id=\"accountService\" class=\"cn.wolfcode.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;!--spring 中基于xml的aop配置 1.把通知bean也交给spring来管理 2.使用aop:comfig标签来表明开始aop的位置 3.使用aop:aspect标签配置切面 id属性:给切面提供唯一id; ref属性:指定通知类bean的id 4:在上述标签内部使用对应标签配置通知类型 aop:before表明配置前置通知 method属性:用于指定Logger类中哪个方法是前置通知 pointcut属性:用于指定切入点表达式 切入点表达式: 关键字:execution(表达式) 标准写法:访问修饰符 包名.包名...类名.方法名 访问修饰符可以省略 返回值可以使用通配符表示任意返回值 包名使用通配符表示任意包,但是有几级包就需要几个*. 包名可以使用..表示当前包和子包 类名和方法名也可以使用通配符来表示,参数列表可以直接写数类型,引用写包名.类名.或者用..表示通配 全通配写法:* *..*.*() --&gt; &lt;bean class=\"cn.wolfcode.utils.Logger\" id=\"logger\"&gt;&lt;/bean&gt; &lt;!--配置aop--&gt; &lt;aop:config&gt; &lt;!--配置切入点表达式 有约束,必须出现在aspect标签之前--&gt; &lt;aop:pointcut id=\"pt1\" expression=\"execution( * *..*.*(..))\"/&gt; &lt;aop:aspect id=\"logAdivce\" ref=\"logger\"&gt; &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:before&gt; &lt;aop:after-returning method=\"afterReturningPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=\"afterThrowingPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after-throwing&gt; &lt;aop:after method=\"afterPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:after&gt; &lt;!--配置环绕通知--&gt; &lt;aop:around method=\"aroundPrintLog\" pointcut-ref=\"pt1\"&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 基于注解的aop通知业务层基本没变化在实现类上加上一个注解 logger类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Component(\"logger\")@Aspect//当前类是个切面类public class Logger &#123; @Pointcut(\"execution( * *..*.*(..))\") private void pt2()&#123;&#125; /** * 前置通知 */ //@Before(\"pt2()\") public void beforePrintLog()&#123; System.out.println(\"前置通知Logger类中的beforePrintLog方法开始记录日志了\"); &#125; /** * 异常通知 */ //@AfterThrowing(\"pt2()\") public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了\"); &#125; /** * 后置通知 */ //@AfterReturning(\"pt2()\") public void afterReturningPrintLog()&#123; System.out.println(\"后置通知Logger类中的afterReturningPrintLog方法开始记录日志了\"); &#125; /** * 最终通知 */ //@After(\"pt2()\") public void afterPrintLog() &#123; System.out.println(\"最终通知Logger类中的afterPrintLog方法开始记录日志了\"); &#125; /** * 环绕通知 */ @Around(\"pt2()\") public void aroundPrintLog(ProceedingJoinPoint pjp) &#123; Object reValue = null; try &#123; Object[] args = pjp.getArgs(); beforePrintLog(); reValue = pjp.proceed(args); afterReturningPrintLog(); &#125; catch (Throwable throwable) &#123; afterThrowingPrintLog(); &#125;finally &#123; afterPrintLog(); &#125; System.out.println(\"Logger类中的aroundPrintLog方法开始记录日志了\"); &#125;&#125; xml中开启包扫描和注解支持 1234&lt;context:component-scan base-package=\"cn.wolfcode\"&gt;&lt;/context:component-scan&gt;&lt;!--开启注解aop支持--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;","pubDate":"Fri, 07 Aug 2020 08:58:37 GMT","guid":"https://labixioazhan.github.io/2020/08/07/spring基础/","category":"Spring"},{"title":"Mybatis","link":"https://labixioazhan.github.io/2020/08/06/Mybatis/","description":"mybatis基于xml的操作(不写实现类)myabtis配置文件:这里使用properties文件将数据库相关信息抽取 注意一定要在最后引入映射文件的位置 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--作用: 引用数据库配置文件 --&gt; &lt;properties resource=\"db.properties\"/&gt; &lt;!--作用: 配置环境(可以配多个)--&gt; &lt;environments default=\"development\"&gt; &lt;!--作用: 配置环境变量--&gt; &lt;environment id=\"development\"&gt; &lt;!--作用: 事物管理器 JDBC 含义:使用jdbc类型的事务管理器 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!--作用:数据源 POOLED含义:数据源类型:数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driverClassName&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--作用:配置去哪里可以找到sql映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"cn\\wolfcode\\dao\\EmpDao.xml\"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt;","pubDate":"Thu, 06 Aug 2020 10:00:21 GMT","guid":"https://labixioazhan.github.io/2020/08/06/Mybatis/","category":"mybatis"},{"title":"Maven的安装与配置","link":"https://labixioazhan.github.io/2020/08/03/Maven/","description":"Mavenmaven的安装 检查JDK版本,打开命令行输入java -version,如果报错可能是没有配置环境变量导致的,给java配置环境变量 将下载好的maven压缩包解压,解压后的路径最好不要使用中文和空格\\ 配置maven的环境变量 打开命令行输入mvn -v检查是否安装成功 maven设置本地仓库路径和更改仓库镜像 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;!-- 本地仓库地址 --&gt; &lt;localRepository&gt;你本地仓库的目录位置&lt;/localRepository&gt; &lt;mirrors&gt; &lt;!-- 阿里仓库镜像 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;/settings&gt;","pubDate":"Mon, 03 Aug 2020 06:16:45 GMT","guid":"https://labixioazhan.github.io/2020/08/03/Maven/","category":"Maven"},{"title":"myPhoto","link":"https://labixioazhan.github.io/2020/08/02/myPhoto/","description":"","pubDate":"Sun, 02 Aug 2020 06:00:05 GMT","guid":"https://labixioazhan.github.io/2020/08/02/myPhoto/","category":"photo"},{"title":"Hello World","link":"https://labixioazhan.github.io/2020/08/02/hello-world/","description":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","pubDate":"Sun, 02 Aug 2020 02:16:46 GMT","guid":"https://labixioazhan.github.io/2020/08/02/hello-world/","category":""}]}